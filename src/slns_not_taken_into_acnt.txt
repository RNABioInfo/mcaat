    //was in cycle_finder!
        int DFSApproach(){
            int count = _CountStartNodes();
            
            std::stack<uint64_t> memory_stack;
            map<int,bool> visited;
            
            for (uint64_t i = 0; i < cycle_properties.succinct_de_bruijn_graph.size(); i++)
            {
                int indegree = cycle_properties.succinct_de_bruijn_graph.EdgeIndegree(i);
                
                if (indegree == 0 && !visited[i]){ 
                    memory_stack.push(i);
                    visited[i] = true;
                    while(!memory_stack.empty()){
                        uint64_t node = memory_stack.top();
                        memory_stack.pop();
                        set<uint64_t> neighbors = _GetOutgoings(node);
                        for (auto neighbor : neighbors){
                            if (cycle_properties.visited[i])
                                cycle_properties.visited[i] = false;
                        }
                    }
                }
            }

            return count;
        }

    int _CountStartNodes(){
            int count = 0;
            for (uint64_t i = 0; i < cycle_properties.succinct_de_bruijn_graph.size(); i++)
            {
                int indegree = cycle_properties.succinct_de_bruijn_graph.EdgeIndegree(i);
                if (indegree == 0){ 
                    count+=1;
                    cout<<i<<endl;
                }
                
            }
            return count;
        }
        /// @brief Find all nodes with indegree > 1, used for setting all the start nodes 
        /// @return uint64_t vector of all nodes with indegree > 1
        vector<uint64_t> _IndegreeMoreThanOne(){
            vector<uint64_t> nodes_more_than_one;
            for (uint64_t i = 0; i < cycle_properties.succinct_de_bruijn_graph.size(); i++)
            {
                int indegree = cycle_properties.succinct_de_bruijn_graph.EdgeIndegree(i);
                if (indegree >1)
                {
                    nodes_more_than_one.push_back(i);
                }
            }
            return nodes_more_than_one;
        };

        void _InitialValues(uint64_t start_node){
            path.push_back(start_node);
            lock[start_node] = 0;
            stack.push_back(_GetOutgoings(start_node));
            backtrack_lengths.push_back(maximal_length);
        };